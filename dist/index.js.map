{
  "version": 3,
  "sources": ["../src/component.js", "../src/reactive.js", "../src/effect.js", "../src/nodeOps.js", "../src/props.js", "../src/scheduler.js", "../src/apiWatch.js", "../src/apiComputed.js", "../src/index.js"],
  "sourcesContent": ["import { finishComponentSetup } from './index'\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (\n  val,\n  key\n) => hasOwnProperty.call(val, key)\n\nexport const PublicInstanceProxyHandlers = {\n  get({ _: instance }, key) {\n    const { ctx, setupState, data, props, accessCache, type, appContext } =\n      instance;\n    if (key[0] !== \"$\") {\n      const n = accessCache[key];\n      if (n !== undefined) {\n        switch (n) {\n          case 1:\n            return setupState[key];\n          case 2:\n            return data[key];\n          case 4:\n            return ctx[key];\n          case 3:\n            return props[key];\n        }\n      } else if (hasOwn(setupState, key)) {\n        accessCache[key] = 1\n        return setupState[key]\n      } else if (hasOwn(data, key)) {\n        accessCache[key] = 2\n        return data[key]\n      } else if (hasOwn(props, key)) {\n        accessCache[key] = 3\n        return props[key]\n      } else if (hasOwn(ctx, key)) {\n        accessCache[key] = 4\n        return ctx[key]\n      }\n    }\n  },\n  set({ _: instance }, key, value) {\n    const { data, setupState, ctx } = instance\n    if (hasOwn(setupState, key)) {\n        setupState[key] = value\n        return true\n    } else if (hasOwn(data, key)) {\n        data[key] = value\n        return true\n    } else if (hasOwn(instance.props, key)) {\n        warn(`Attempting to mutate prop \"${key}\". Props are readonly.`)\n        return false\n    }\n  }\n};\n\nconst shallowUnwrapHandlers = {\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n    set: (target, key, value, receiver) => {\n        const oldValue = target[key]\n        if (isRef(oldValue) && !isRef(value)) {\n            oldValue.value = value\n            return true\n        } else {\n            return Reflect.set(target, key, value, receiver)\n        }\n    }\n}\n\nexport function unref(ref){\n    return isRef(ref) ? (ref.value) : ref\n  }\n\nexport function isRef (r) {\n    return !!(r && r.__v_isRef === true)\n}\n\nexport function isReactive(value) {\n    return !!(value && value['__v_isReactive'])\n}\n\nfunction proxyRefs (objectWithRefs) {\n    return isReactive(objectWithRefs)\n    ? objectWithRefs\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\n}\n\nexport const handleSetupResult = (instance, setupResult) => {\n    instance.setupState = proxyRefs(setupResult)\n    finishComponentSetup(instance)\n}\n\nexport function applyOptions(instance) {\n    const ctx = instance.ctx\n    const publicThis = instance.proxy\n    const { methods } = instance.type\n    if (methods) {\n        for (const key in methods) {\n            const methodHandler = methods[key]\n            if (typeof methodHandler === 'function') {\n                ctx[key] = methodHandler.bind(publicThis)\n            }   \n        }\n    }\n}", "import { track, trigger, pauseTracking, resetTracking, ITERATE_KEY } from './effect'\nimport { hasChanged, toRaw } from './index'\nimport { isRef, hasOwn } from './component'\nexport const reactiveMap = new WeakMap()\n\nexport const isIntegerKey = (key) => {\n    return ((typeof key === 'string') &&\n    key !== 'NaN' &&\n    key[0] !== '-' &&\n    '' + parseInt(key, 10) === key)\n}\n\nexport function markRaw (value) {\n    Object.defineProperty(value, '__v_skip', {\n        configurable: true,\n        enumerable: false,\n        value: true\n    })\n    return value\n}\n\nexport const toReactive = (value) => {\n    return (value !== null && typeof value === 'object') ? reactive(value) : value\n}\n\nexport const reactive = (target) => {\n    return createReactiveObject(\n      target,\n      false,\n      mutableHandlers,\n      reactiveMap\n    )\n}\n\n\nfunction createReactiveObject(\n    target,\n    isReadonly,\n    baseHandlers,\n    proxyMap\n  ) {\n    if (!(target !== null && typeof target === 'object')) {\n        return target\n    }\n\n    const existingProxy = proxyMap.get(target)\n    if (existingProxy) {\n        return existingProxy\n    }\n\n    const proxy = new Proxy(target,  baseHandlers)\n    proxyMap.set(target, proxy)\n    return proxy\n  }\n\n  const arrayInstrumentations = createArrayInstrumentations()\n  function createArrayInstrumentations() {\n    const instrumentations = {}\n    ;['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            const arr = toRaw(this)\n            for (let i = 0, l = this.length; i < l; i++) {\n                track(arr, 'get', i + '')\n            }\n            const res = arr[key](...args)\n            if (res === -1 || res === false) {\n                return arr[key](...args.map(toRaw))\n            } else {\n                return res\n            }\n        }\n    })\n\n    ;['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            pauseTracking()\n            const res = toRaw(this)[key].apply(this, args)\n            resetTracking()\n            return res\n        }\n    })\n    return instrumentations\n  }\n\n\n  export const mutableHandlers = {\n    get (target, key, receiver) {\n        if (key === '__v_isReactive') {\n            return true\n        }\n        if (key === '__v_raw' && receiver === reactiveMap.get(target)) {\n            return target\n        }\n\n\n        const targetIsArray = Array.isArray(target)\n        const res = Reflect.get(target, key, receiver)\n\n        if (key === '__v_isRef' || key === '__proto__' || key === '__isVue') {\n            return res\n        }\n\n        if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n            return Reflect.get(arrayInstrumentations, key, receiver)\n        }\n        track(target, 'get', key)\n\n        if (isRef(res)) {\n            return res.value\n        }\n        return res\n    },\n    set (target, key, value, receiver) {\n        let oldValue = target[key]\n        oldValue = toRaw(oldValue)\n        value = toRaw(value)\n        const hasKey = Array.isArray(key) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key)\n        const result = Reflect.set(target, key, value, receiver)\n        if (!hasKey) {\n            trigger(target, 'add', key, value)\n        } else if (hasChanged(value, oldValue)) {\n            trigger(target, 'set', key, value, oldValue)\n        }\n        return result\n    },\n    deleteProperty () {\n\n    },\n    has () {\n\n    },\n    ownKeys (target) {\n        track(target, 'iterate', Array.isArray(target) ? 'length' : ITERATE_KEY)\n        return Reflect.ownKeys(target)\n    }\n  }", "import { toRaw }  from './index'\nimport { isIntegerKey } from './reactive';\n\n\nexport const ITERATE_KEY = Symbol('iterate')\nconst targetMap = new WeakMap();\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\nconst maxMarkerBits = 30;\n\nlet activeEffect;\nconst trackStack = []\nlet shouldTrack = true;\n\nexport class ReactiveEffect {\n  active = true;\n  deps = [];\n  parent = undefined;\n  fn;\n  scheduler;\n\n  constructor(fn, scheduler) {\n    this.fn = fn;\n    this.scheduler = scheduler;\n  }\n\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n    let parent = activeEffect;\n    while (parent) {\n      if (parent === this) {\n        return\n      }\n      parent = parent.parent\n    }\n    let lastShouldTrack = shouldTrack;\n    try {\n      this.parent = activeEffect;\n      activeEffect = this;\n      shouldTrack = true;\n\n      trackOpBit = 1 << ++effectTrackDepth;\n\n      return this.fn();\n    } finally {\n      trackOpBit = 1 << --effectTrackDepth;\n\n      activeEffect = this.parent;\n      shouldTrack = lastShouldTrack;\n      this.parent = undefined;\n    }\n  }\n}\n\nexport const createDep = (effects) => {\n  const dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\n\nexport function track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n      targetMap.set(target, (depsMap = new Map()))\n    }\n    let dep = depsMap.get(key)\n    if (!dep) {\n      depsMap.set(key, (dep = createDep()))\n    }\n    trackEffects(dep)\n  }\n}\n\n\nexport function trackEffects(dep) {\n  let shouldTrack = false;\n\n  dep.add(activeEffect);\n  activeEffect.deps.push(dep);\n}\n\nexport function trackRefValue(ref) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref);\n    trackEffects(ref.dep || (ref.dep = createDep()));\n  }\n}\n\nexport function trigger (target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target)\n  if (!depsMap) {\n    // never been tracked\n    return\n  }\n  let deps = []\n\n  if (type === 'clear') {\n\n  } else if (key === 'length' && Array.isArray(target)) {\n    const newLength = Number(newValue)\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= newLength) {\n        deps.push(dep)\n      }\n    })\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key))\n    }\n\n    switch (type) {\n      case 'add':\n        if (!Array.isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n        } else if (isIntegerKey(key)) {\n          deps.push(depsMap.get('length'))\n        }\n    }\n  }\n\n  if (deps.length === 1) {\n    if (deps[0]) {\n      triggerEffects(deps[0])\n    }\n  } else {\n    const effects = []\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep)\n      }\n    }\n    triggerEffects(createDep(effects))\n  }\n}\n\nexport function triggerEffects(dep) {\n  const effects = Array.isArray(dep) ? dep : [...dep];\n  for (const effect of effects) {\n    if (effect.computed) {\n      triggerEffect(effect);\n    }\n  }\n  for (const effect of effects) {\n    if (!effect.computed) {\n      triggerEffect(effect);\n    }\n  }\n}\n\nexport function triggerEffect (effect) {\n    if (effect !== activeEffect) {\n      if (effect.scheduler) {\n        effect.scheduler()\n      } else {\n        effect.run()\n      }\n    }\n}\n\nexport function triggerRefValue(ref, newVal) {\n  ref = toRaw(ref);\n  const dep = ref.dep;\n  if (dep) {\n    triggerEffects(dep);\n  }\n}\n\n\nexport function pauseTracking () {\n  trackStack.push(shouldTrack)\n  shouldTrack = false\n}\n\nexport function resetTracking() {\n  const last = trackStack.pop()\n  shouldTrack = last === undefined ? true : last\n}", "export const nodeOps = {\n    insert: (child, parent, anchor) => {\n        parent.insertBefore(child, anchor || null)\n    },\n    setElementText: (el, text) => {\n        el.textContent = text\n    },\n    createElement (tag) {\n        const el = document.createElement(tag)\n        return el\n    },\n    parentNode(node) {\n        return node.parentNode\n    },\n    nextSibling (node) {\n        return node => node.nextSibling\n    },\n    remove (child) {\n        const parent = child.parentNode\n        if (parent) {\n        parent.removeChild(child)\n        }\n    }\n}", "const onRE = /^on[^a-z]/\nexport const isOn = (key) => onRE.test(key)\nexport const isModelListener = (key) => key.startsWith('onUpdate:')\n\nexport const patchProp = (\n    el,\n    key,\n    prevValue,\n    nextValue,\n    isSVG = false,\n    prevChildren,\n    parentComponent,) => {\n        if (isOn(key)) {\n            if (!isModelListener(key)) {\n                patchEvent(el, key, prevValue, nextValue, parentComponent)\n            }\n        }\n}\nconst hyphenateRE = /\\B([A-Z])/g\nconst hyphenate = (str) =>\n  str.replace(hyphenateRE, '-$1').toLowerCase()\n\n\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/\n\nfunction parseName(name) {\n    let options\n    if (optionsModifierRE.test(name)) {\n\n    }\n    const event = name[2] === ':' ? name.slice(3) : hyphenate(name.slice(2))\n    return [event, options]\n}\n\nconst createInvoker = (initialValue, instance) => {\n    const invoker = (e) => {\n        invoker.value.call(instance, [e])\n    }\n    invoker.value = initialValue\n    // invoker.attached = getNow()\n    return invoker\n}\n\nexport function addEventListener(\n    el,\n    event,\n    handler,\n    options\n  ) {\n    el.addEventListener(event, handler, options)\n  }\n\nexport function patchEvent(el, rawName, prevValue, nextValue, instance) {\n    const invokers = el._vei || (el._vei = {})\n    const [name, options] = parseName(rawName)\n    if (nextValue) {\n        const invoker = (invokers[rawName] = createInvoker(nextValue, instance))\n        addEventListener(el, name, invoker, options)\n    }\n}", "const queue = [];\nlet isFlushing = false\nlet isFlushPending = false\nconst resolvedPromise = Promise.resolve()\nlet currentFlushPromise = null\nlet flushIndex = 0\n\nexport function queueJob(job) {\n  if (!queue.length || !queue.includes(job)) {\n    queue.push(job);\n    queueFlush();\n  }\n}\n\nfunction queueFlush() {\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true\n    currentFlushPromise = resolvedPromise.then(flushJobs)\n  }\n}\n\nfunction flushJobs(seen) {\n  isFlushPending = false\n  isFlushing = true\n  try {\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex]\n      if (job && job.active !== false) {\n        job()\n      }\n    }\n  } finally {\n    flushIndex = 0\n    queue.length = 0\n    isFlushing = false\n    currentFlushPromise = null\n  }\n}", "import { isRef, isReactive } from './component'\nimport { ReactiveEffect } from './effect'\nimport { queueJob } from './scheduler'\n\nexport function watch (source, cb, { immediate, deep, flush, onTrack, onTrigger } = {}) {\n    let getter = () => {}\n    if (isRef(source)) {\n        getter = () => source.value\n    } else if (isReactive(source)) {\n        getter = () => source\n        deep = true\n    } else if (Array.isArray(source)) {\n        getter = () => {\n            return source.map(s => {\n                if (isRef(s)) {\n                    return s.value\n                } else if (isReactive(s)) {\n                    return traverse(s)\n                }\n            })\n        }        \n    }\n\n    const job = () => {\n        if (!effect.active) {\n            return\n        }\n        if (cb) {\n            const newValue = effect.run()\n            cb(newValue)\n        }\n    }\n\n    let scheduler = () => queueJob(job)\n\n    const effect = new ReactiveEffect(getter, scheduler)\n\n    if (cb) {\n        if (immediate) {\n            job()\n        } else {\n            oldValue = effect.run()\n        }\n    }\n}\n\n\nexport function traverse (value, seen) {\n    if (!(typeof value === 'object' && value !== 'null')) return value\n    seen = seen || new Set()\n    if (seen.has(value)) {\n        return value\n    }\n    seen.add(value)\n    if (isRef(value)) {\n        traverse(value.value, seen)\n    } else if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n            traverse(value[i], seen)\n        }\n    }\n    return value\n}", "import { toRaw } from \".\"\nimport { ReactiveEffect, triggerRefValue, trackRefValue } from \"./effect\"\n\nexport function computed (getterOrOptions) {\n    let getter\n    let setter\n    const onlyGetter = typeof getterOrOptions === 'function'\n    if (onlyGetter) {\n        getter = getterOrOptions\n        setter = () => {}\n    } else {\n        getter = getterOrOptions.get\n        setter = getterOrOptions.set\n    }\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter)\n    return cRef\n}\n\n\nexport class ComputedRefImpl {\n    __v_isRef = true\n    _dirty = true\n    _value\n    _cacheable\n    constructor (getter, _setter, isReadonly) {\n        this.getter = getter\n        this._setter = _setter\n        this.effect = new ReactiveEffect(getter, () => {\n            if (!this._dirty) {\n                this._dirty = true\n                triggerRefValue(this)\n            }\n        })\n        this.effect.computed = this\n    }\n\n    get value () {\n        const self = toRaw(this)\n        trackRefValue(this)\n        if (self._dirty || !self._cacheable) {\n            self._dirty = false\n            self._value = self.effect.run()\n        }\n        return self._value\n    }\n\n    set value (newValue) {\n        this._setter(newValue)\n    }\n}", "import { ReactiveEffect, trackRefValue, triggerRefValue } from \"./effect\";\nimport { nodeOps } from \"./nodeOps\";\nimport { markRaw, toReactive, reactive } from './reactive'\nimport { PublicInstanceProxyHandlers, handleSetupResult, applyOptions, isRef } from './component'\nimport { patchProp as hostPatchProp } from './props'\nimport { queueJob } from './scheduler'\nimport { watch } from './apiWatch'\nimport { computed } from './apiComputed'\nconst EMPTY_OBJ = Object.freeze({})\nconst {\n  insert: hostInsert,\n  createElement: hostCreateElement,\n  setElementText: hostSetElementText,\n  nextSibling: hostNextSibling,\n  parentNode: hostParentNode,\n  remove: hostRemove\n} = nodeOps;\n\nlet isMounted = false;\nlet uid = 0;\nconst createVNode = (type, props, children) => {\n  const shapeFlag = typeof type === \"string\" ? 1 : 4;\n  const vnode = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type,\n    props,\n    children,\n    shapeFlag,\n  };\n  if (children) {\n    vnode.shapeFlag = typeof children === \"string\" ? 8 : 16;\n  }\n  return vnode;\n};\n\nconst initProps = (instance, rawProps, isStateful) => {\n  const props = {}\n  instance.propsDefaults = Object.create(null)\n  if (isStateful) {\n    instance.props = props\n  }\n}\n\nexport function finishComponentSetup(instance) {\n  const Component = instance.type;\n  if (!instance.render) {\n    instance.render = Component.render;\n  }\n  applyOptions(instance)\n}\n\nconst createComponentInstance = (vnode, parent) => {\n  const type = vnode.type;\n  const instance = {\n    uid: uid++,\n    vnode,\n    type,\n    parent,\n\n    ctx: EMPTY_OBJ,\n    data: EMPTY_OBJ,\n    props: EMPTY_OBJ,\n    attrs: EMPTY_OBJ,\n    slots: EMPTY_OBJ,\n    refs: EMPTY_OBJ,\n    setupState: EMPTY_OBJ,\n    setupContext: null,\n  };\n  instance.ctx = { _: instance }\n  instance.root = parent ? parent.root : instance;\n  return instance;\n};\n\nconst normalizeVNode = (child) => {\n  return child;\n};\n\nconst renderComponentRoot = (instance) => {\n  const {\n    type: Component,\n    vnode,\n    proxy,\n    withProxy,\n    props,\n    propsOptions,\n    slots,\n    attrs,\n    emit,\n    render,\n    renderCache,\n    data,\n    setupState,\n    ctx,\n    inheritAttrs,\n  } = instance;\n  let result;\n  if (vnode.shapeFlag === 4) {\n    const proxyToUse = withProxy || proxy\n    result = normalizeVNode(\n      render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx)\n    );\n  }\n  return result;\n};\n\nconst createApp = (...args) => {\n  const [rootComponent, rootProps = null] = [...args];\n  function processElement(\n    n1,\n    n2,\n    container,\n    anchor = null,\n    parentComponent = null\n  ) {\n    if (n1 == null) {\n      mountElement(n2, container, anchor, parentComponent);\n    } else {\n      patchElement(n1, n2, parentComponent)\n    }\n  }\n\n  const getNextHostNode = vnode => {\n    return hostNextSibling(vnode.anchor || vnode.el)\n  }\n\n  const mountElement = (vnode, container, anchor, parentComponent) => {\n    let el;\n    const { type, props, shapeFlag, transition, dirs } = vnode;\n    el = vnode.el = hostCreateElement(vnode.type);\n\n    if (vnode.shapeFlag === 8) {\n      hostSetElementText(el, vnode.children);\n    } else if (vnode.shapeFlag === 16) {\n      mountChildren(vnode.children, el, null, parentComponent);\n    }\n    if (props) {\n      for (const key in props) {\n        if (key !== 'value') {\n          hostPatchProp(\n            el,\n            key,\n            null,\n            props[key],\n            false,\n            vnode.children,\n            parentComponent\n          )\n        }\n      }\n    }\n    hostInsert(el, container, anchor);\n  };\n\n  const patchElement = (n1, n2, parentComponent) => {\n    const el = (n2.el = n1.el)\n    let { children } = n2\n    patchChildren(\n      n1,\n      n2,\n      el,\n      null,\n      parentComponent\n    )\n    // if (n1.children !== n2.children) {\n    //   hostSetElementText(el, n2.children)\n    // }\n  }\n\n  const patchChildren = (\n    n1,\n    n2,\n    container,\n    anchor,\n    parentComponent,\n  ) => {\n    const c1 = n1 && n1.children\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0\n    const c2 = n2.children\n\n    const { shapeFlag } = n2\n    if (shapeFlag === 8) {\n      if (prevShapeFlag === 16) {\n        unmountChildren(c1, parentComponent)\n      }\n      if (c2 !== c1) {\n        hostSetElementText(container, c2)\n      }\n    } else {\n      if (prevShapeFlag === 16) {\n        if (shapeFlag === 16) {\n          patchKeyedChildren(\n            c1,\n            c2,\n            container,\n            anchor,\n            parentComponent,\n          )\n        } else {\n          unmountChildren(c1, parentComponent)\n        }\n      } else {\n        if (prevShapeFlag === 8) {\n          hostSetElementText(container, '')\n        }\n\n        if (shapeFlag === 16) {\n          mountChildren(\n            c2,\n            container,\n            anchor,\n            parentComponent\n          )\n        }\n      }\n    }\n\n  }\n\n  const patchKeyedChildren = (\n    c1,\n    c2,\n    container,\n    parentAnchor,\n    parentComponent,\n  ) => {\n    let i = 0\n    const l2 = c2.length\n    let e1 = c1.length - 1 // prev ending index\n    let e2 = l2 - 1 // next ending index\n\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i]\n      const n2 = c2[i]\n      if (n1.type === n2.type && n1.key === n2.key) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n        )\n      } else {\n        break\n      }\n      i++\n    }\n\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i]\n      const n2 = c2[i]\n      if (n1.type === n2.type && n1.key === n2.key) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n        )\n      } else {\n        break\n      }\n      e1--\n      e2--\n    }\n\n    if (i > e1) {\n      if (i <= e2) {\n        const nextPos = e2 + 1\n        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor\n        while (i <= e2) {\n          patch(\n            null,\n            c2[i],\n            container,\n            anchor,\n            parentComponent,\n          )\n          i++\n        }\n      }\n    } else if (i > e2) {\n      while (i <= e1) {\n        unmount(c1[i], parentComponent)\n        i++\n      }\n    } else {\n      const s1 = i\n      const s2 = i\n      const keyToNewIndexMap = new Map()\n      for (i = s2; i <= e2; i++) {\n        const nextChild = c2[i]\n        if (nextChild.key != null) {\n          keyToNewIndexMap.set(nextChild.key, i)\n        }\n      }\n\n      let j\n      let patched = 0\n      const toBePatched = e2 - s2 + 1\n      let moved = false\n      let maxNewIndexSoFar = 0\n\n      const newIndexToOldIndexMap = new Array(toBePatched)\n      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0\n\n      for (i = s1; i <= e1; i++) {\n        const prevChild = c1[i]\n        if (patched >= toBePatched) {\n\n        }\n        let newIndex\n        if (prevChild.key != null) {\n          newIndex = keyToNewIndexMap.get(prevChild.key)\n        } else {\n          for (j = s2; j <= e2; j++) {\n            if (\n              newIndexToOldIndexMap[j - s2] === 0 &&\n              prevChild.type === c2[j].type && prevChild.key === c2[j].key\n            ) {\n              newIndex = j\n              break\n            }\n          }\n        }\n        if (newIndex === undefined) {\n          unmount(prevChild, parentComponent)\n        } else {\n\n        }\n      }\n    }\n  }\n\n  const unmountChildren = (\n    children,\n    parentComponent,\n    start = 0\n  ) => {\n    for (let i = start; i < children.length; i++) {\n      unmount(children[i], parentComponent)\n    }\n  }\n\n  const unmount = (\n    vnode,\n    parentComponent,\n  ) => {\n    const {\n      type,\n      props,\n      ref,\n      children,\n      dynamicChildren,\n      shapeFlag,\n      patchFlag,\n      dirs\n    } = vnode\n    if (shapeFlag === 6) {\n      // unmountComponent(vnode.component)\n    } else {\n      remove(vnode)\n    }\n  }\n\n  const remove = (vnode) => {\n    const { type, el, anchor, transition } = vnode\n    hostRemove(el)\n  }\n\n  const mountChildren = (\n    children,\n    container,\n    anchor,\n    parentComponent,\n    start = 0\n  ) => {\n    for (let i = start; i < children.length; i++) {\n      const child = children[i];\n      patch(null, child, container, anchor, parentComponent);\n    }\n  };\n\n  function processComponent(\n    n1,\n    n2,\n    container,\n    anchor = null,\n    parentComponent = null\n  ) {\n    if (n1 === null) {\n      mountComponent(n2, container, anchor, parentComponent);\n    }\n  }\n\n  function mountComponent(initialVNode, container, anchor, parentComponent) {\n    const instance = createComponentInstance(initialVNode, parentComponent);\n    setupComponent(instance);\n    setupRenderEffect(instance, initialVNode, container, anchor);\n  }\n\n  const setupRenderEffect = (instance, initialVNode, container, anchor) => {\n    const componentUpdateFn = () => {\n      if (!instance.isMounted) {\n        const { el, props } = initialVNode;\n        const subTree = (instance.subTree = renderComponentRoot(instance));\n        patch(null, subTree, container, anchor, instance);\n        instance.isMounted = true\n      } else {\n        let { next, vnode } = instance\n        if (next) {\n          next.el = vnode.el\n        } else {\n          next = vnode\n        }\n        const nextTree = renderComponentRoot(instance)\n        const prevTree = instance.subTree\n        instance.subTree = nextTree\n        patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance);\n      }\n    };\n    const effect = (instance.effect = new ReactiveEffect(\n      componentUpdateFn,\n      () => queueJob(update),\n    ));\n    const update = (instance.update = () => effect.run());\n    update.id = instance.uid;\n    update();\n  };\n\n  function setupComponent(instance) {\n    const { props } = instance.vnode\n    const isStateful = instance.vnode.shapeFlag === 4;\n\n    initProps(instance, props, isStateful)\n\n    const setupResult = isStateful\n      ? setupStatefulComponent(instance)\n      : undefined;\n    \n    return setupResult;\n  }\n\n  function setupStatefulComponent(instance) {\n    const Component = instance.type;\n    instance.accessCache = Object.create(null);\n    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers))\n    const { setup } = Component;\n    if (setup) {\n      const setupResult = setup.call(instance);\n      handleSetupResult(instance, setupResult)\n    } else {\n      finishComponentSetup(instance);\n    }\n  }\n\n  function patch(n1, n2, container, anchor = null, parentComponent = null) {\n    if (n1 === n2) {\n      return;\n    }\n    if (n1 && !(n1.type === n2.type && n1.key === n2.key)) {\n      // anchor = getNextHostNode(n1)\n      // unmount(n1, parentComponent)\n      // n1 = null\n    }\n    const { shapeFlag } = n2;\n\n    if (shapeFlag !== 4) {\n      processElement(n1, n2, container, anchor, parentComponent);\n    } else if (shapeFlag === 4) {\n      processComponent(n1, n2, container, anchor, parentComponent);\n    }\n  }\n  function render(vnode, container) {\n    patch(container._vnode || null, vnode, container, null, null);\n  }\n\n  function mount(rootContainer) {\n    if (!isMounted) {\n      const vnode = createVNode(rootComponent, rootProps);\n      render(vnode, rootContainer);\n      isMounted = true;\n    }\n  }\n\n  console.log(rootComponent);\n  return {\n    mount(containerOrSelector) {\n      const container = document.querySelector(containerOrSelector);\n      container.innerHTML = \"\";\n      mount(container);\n    },\n  };\n};\n\nconst createElementBlock = (...args) => {\n  return createVNode(...args);\n};\nconst createElementVNode = (...args) => {\n  return createVNode(...args);\n};\n\nexport function toRaw(observed) {\n  const raw = observed && observed['__v_raw']\n  return raw ? toRaw(raw) : observed\n}\n\n\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n\nconst ref = (value) => {\n  return createRef(value, false)\n}\n\nclass RefImpl{\n  _value\n  _rawValue\n  dep = undefined\n  __v_isRef = true\n  constructor(value, __v_isShallow) {\n    this._rawValue = __v_isShallow ? value : toRaw(value)\n    this._value = __v_isShallow ? value : toReactive(value)\n  }\n\n  get value () {\n    trackRefValue(this)\n    return this._value\n  }\n\n  set value (newVal) {\n    newVal = toRaw(newVal)\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal\n      this._value = toReactive(newVal)\n      triggerRefValue(this, newVal)\n    }\n  }\n}\n\n\nexport const hasChanged = (value, oldValue) =>\n  !Object.is(value, oldValue)\n\nwindow.Vue = {\n  createApp,\n  createElementBlock,\n  createElementVNode,\n  ref,\n  reactive,\n  watch,\n  computed\n};\n"],
  "mappings": "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",
  "names": ["oldValue", "ref", "oldValue", "shouldTrack", "ref", "oldValue", "key", "node", "ref", "oldValue"]
}
